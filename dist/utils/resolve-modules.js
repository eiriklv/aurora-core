'use strict';

/**
 * Dependencies
 */
var set = require('lodash.set');
var clone = require('stringify-clone');

var resolvedModuleCache = [];
/**
 * Utilities
 */
var generateResolvers = require('./generate-resolvers');

/**
 * A method for actually resolving a config
 * from type names to React components.
 * Takes a config object to be resolved and
 * an array of paths generated by the
 * function above (generatePaths)
 */
module.exports = function () {
  var getModule = arguments.length <= 0 || arguments[0] === undefined ? function () {
    return console.warn('No getModule() method supplied to constructor');
  } : arguments[0];

  return function (config) {
    /**
     * Clone the config object to avoid mutation
     */
    var configCopy = clone(config);
    /**
     * Create an array of resolver specifications
     */
    var resolvers = generateResolvers('app', configCopy.app, function (_ref) {
      var path = _ref.path;
      var module = _ref.module;

      return {
        path: path + '.type',
        type: module.type
      };
    });

    /**
     * Return a Promise of the config
     * resolved with modules
     * (React components instead of type strings)
     */
    return new Promise(function (resolve, reject) {
      var resolvingModules = [];
      resolvers.map(function (item) {
        if (!resolvedModuleCache[item.type]) {
          resolvedModuleCache[item.type] = 'adding';
          console.log('Adding', item.type, 'to cache');
          resolvingModules.push(getModule(item.type).then(function (module) {
            return resolvedModuleCache[item.type] = module;
          }));
        }
      });

      Promise.all(resolvingModules).then(function () {
        resolvers.forEach(function (resolver) {
          var component = resolvedModuleCache[resolver.type];
          set(configCopy, resolver.path, component);
        });
        console.log('config', configCopy);
        resolve(configCopy);
      }).catch(function (err) {
        return reject(err);
      });
    });
  };
};