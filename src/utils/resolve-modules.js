/**
 * Dependencies
 */
const set = require('lodash.set');
const clone = require('stringify-clone');


const resolvedModuleCache = [];
/**
 * Utilities
 */
const generateResolvers = require('./generate-resolvers');

/**
 * A method for actually resolving a config
 * from type names to React components.
 * Takes a config object to be resolved and
 * an array of paths generated by the
 * function above (generatePaths)
 */
module.exports = function(
  getModule = () => console.warn('No getModule() method supplied to constructor')
) {
  return function(config) {
    /**
     * Clone the config object to avoid mutation
     */
     const configCopy = clone(config);
    /**
     * Create an array of resolver specifications
     */
    const resolvers = generateResolvers('app', configCopy.app, ({
      path,
      module
    }) => {
      return {
        path: `${path}.type`,
        type: module.type
      };
    });

    /**
     * Return a Promise of the config
     * resolved with modules
     * (React components instead of type strings)
     */
    return new Promise((resolve, reject) => {
      const resolvingModules = [];
      resolvers.map(item => {
        if(!resolvedModuleCache[item.type]) {
          resolvedModuleCache[item.type] = 'adding';
          console.log('Adding', item.type, 'to cache');
          resolvingModules.push(
            getModule(item.type).then(module => resolvedModuleCache[item.type] = module)
          );
        }
      });

      Promise.all(resolvingModules)
      .then(() => {
        resolvers.forEach(resolver => {
          const component = resolvedModuleCache[resolver.type];
          set(configCopy, resolver.path, component);
        });
        console.log('config', configCopy);
        resolve(configCopy);
      })
      .catch(err => reject(err));

    });
  };
};
